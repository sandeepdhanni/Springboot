Reactive programming or reactive streams:

Reactive stream specification is nothing but the rule to design a reactive programming just like how we have oop's language similar way we need to follow...Reactive Streams is a standard for asynchronous stream processing with non-blocking backpressure.it is a asynchronous and non-blocking 


Why Reactive Streams?
In traditional (imperative) programming:
You fetch all data at once (blocking).
System can be overloaded if too much data is fetched at once.
In Reactive Streams:
You react to data as it arrives.
You request data only as you can handle it (this is called backpressure).


when to use reactive programming ?
when there is a need to build app that supports very high load..
Spring WebFlux (Reactive stack) uses Netty by default instead of traditional servlet containers like Tomcat or Jetty.
üöÄ Netty vs. Tomcat (Servlet-based)
Feature	                   Netty (used by WebFlux)	                 Tomcat (used by Spring MVC)
Architecture	     Event-loop based (non-blocking)	          Thread-per-request (blocking)
Reactive Support	 Built for reactive, non-blocking I/O	    Not designed for non-blocking by default



Why WebFlux Uses Netty
Reactive programming is asynchronous and non-blocking, and Netty is designed for that.
Netty operates using event-driven I/O and non-blocking sockets, which makes it efficient for high concurrency with fewer threads.
Tomcat is designed for blocking servlet APIs, so it‚Äôs less efficient for reactive flows.






What Are Non-Blocking Calls?
üßµ Blocking I/O (Traditional / Servlet-based)
In traditional Spring MVC (Tomcat-based):
When a request comes in, a new thread is allocated to handle it.
If that thread makes a network call (e.g., to a DB or external API), it waits (blocks) until the result comes back.
That thread is occupied and cannot do anything else.
Example:
@GetMapping("/user")
public String getUser() {
    String user = restTemplate.getForObject(...);  // This blocks!
    return user;
}
‚ö†Ô∏è Problem: As user traffic increases, the server must spin up more threads ‚Äî leading to high memory use and thread contention.

‚ö° Non-Blocking I/O (Reactive / Netty-based)?
In WebFlux, everything is non-blocking and asynchronous.
When a request comes in, it's handled by a small pool of threads (event loops).
If a network call is needed, the thread does not wait ‚Äî the call is registered, and the thread is released to do other work.
When the response arrives, the framework resumes processing using callbacks or reactive streams.
Example with WebClient (non-blocking):
@GetMapping("/user")
public Mono<String> getUser() {
    return webClient.get()
                    .uri("https://some-api.com/user")
                    .retrieve()
                    .bodyToMono(String.class); // Non-blocking
}
üß† Under the hood:
The I/O operation runs asynchronously.
The response is pushed into a reactive stream (Mono/Flux) once available.





Reactive Streams has 4 main interfaces (defined in the specification):

Interface	            Responsibility
Publisher<T>	Produces data and sends it to a subscriber
Subscriber<T>	Consumes the data
Subscription	Represents the link between Publisher & Subscriber (used for backpressure)
Processor<T,R>	A processor acts as both Subscriber and Publisher



it has four interface:
* Publisher
* Subscriber
* Subscription 
* Processor

* Publisher - it is the datasource who will publish the event..
  Method signature - 
    public interface Publish<T>{
	public void subscribe(Subscriber<? super T> s);
	}
	
* subscriber - subscriber will subscribe/consume the events from publisher...
  Method signature -
  public interface Subscriber<T>{
  public void onNext(T t);
  public void onError(Throwable t);
  public void onComplete();\
  }
  
* Subscription - subscription represents the unique relationship between a subscriber adn publisher..
  Method signature -
  public interface subscription(long n){
  public void request(long n);
  public void cancel();  
  }
  
* Processor - processor represents processing stage which is both publisher and subscriber and mush obey the contracts of both.it extends both publisher and subscriber..Processor can behave as subscribe and publisher...
  Method signature -
  public interface Processor<T,R> extends Subscriber<T>,Publisher<R>{
  }
  
  
Reactive stream workflow -
Flow of Reactive Streams
Publisher ‚Üí has data
Subscriber ‚Üí wants data
Subscriber subscribes to Publisher
Publisher sends data only as requested
Subscriber controls flow via request(n)
If needed, cancel() can stop the stream
                                                 ----------
                  |---------------------------- | Publisher|-------------------
				  |                |           |  ---------   |               |
				  |                |           |              |               |
	  subscribe() 1  subscription()2 Request() 3 onNext(data) 4 onNext(data)  5 onComplete() or onError() 
				  |                |           |              |               |
				  |                |           |              |               |                        |-----------|
                  |----------------------------------------------------------------------------------  | Subscriber|
                                                                                                       |-----------|

we have subscriber and publisher ...
* first subscriber will invoke the subscribe method of publisher and pass the instance of subscribe instance as a input..
* next publisher will send the subscription event to the subscriber confirming that subscription is successful
* subscriber will call the request method from subscription interface to get the data from publisher.the method signature is Request(n) which means subscriber can request n number of request data from publisher
* publisher will sent the data stream to subscriber by invoking onNext(data) method.
  Eg: publisher is returning 10 records..publisher will fire 10 times onNext event.if publisher send n number of data then there will be n time onNext event process..
* once all the record received by subscriber then publisher will invoke one onComeplete method of subscriber to confirm that the job is done..if there is any error then publisher will fire onError event..




 What is Backpressure?
Backpressure is a mechanism to avoid overwhelming consumers. It allows the Subscriber to say:
"Hey Publisher, I can only handle 5 items at a time."
This prevents memory overflows and keeps the system responsive.
Eg: if an application is requesting for n number of data and in the database it is having huge number of data...but the application here is not able to handle that much load so that time we must tell the database that we are not able to handle the load...we will say we need this amouunt of data so send only that data...


Mono vs Flux: Core Difference
Feature 	           Mono	                                             Flux
Purpose	      Represents 0 or 1 item	                      Represents 0 to N items
Use Case	  For single result (e.g., findById)	          For multiple results (e.g., findAll)
Completion	  Completes with success or error	              Completes after emitting N items or error
Publisher	  Part of Reactive Streams specification	      Part of Reactive Streams specification

Mono<T> ‚Üí A container that will eventually hold one item (or none).
Like: Optional<T> but async.
Example :
private Mono<String> testMono(){
        return Mono.just(null);
    }
* Mono will not accept null values

Flux<T> ‚Üí A container that will eventually emit many items over time.
Like: List<T> but async.


Note :
* when we create a flux and subscriber fully uses it and everything goes well but when someone cancel the subscription..when u make a subscription it return a disposable...so using this disposable we can cancel the publisher connection to the subscriber..
*When someone cancels a subscription to a Flux in Reactive Programming, the stream stops emitting data and the underlying resources (like network connections, database cursors, threads, etc.) can be released or cleaned up.
*What Happens on Flux Subscription Cancel?
Signal is sent upstream:
The cancel() signal travels up the chain to the producer/operator that created the Flux.
Data emission stops:
The publisher stops pushing items to the subscriber.
Resources may be cleaned up:
If the Flux was reading a file, querying a DB, or streaming data, those operations can be terminated.
No further signals sent downstream:
After cancellation, no onNext, onError, or onComplete signals are sent.
Eg: 
public class ReactiveTutorial{
 private Flux<Integer> testDoFunctions3() {
        Flux<Integer> flux = Flux.range(1, 10)
                .delayElements(Duration.ofSeconds(1));
        return flux.doOnCancel(() -> System.out.println("Cancelled!"));
    }
	 public static void main(String[] args) throws InterruptedException {
        ReactiveTutorial reactiveTutorial = new ReactiveTutorial();
        Disposable disposable=reactiveTutorial.testDoFunctions3().subscribe(System.out:println);
		disposable.dispose(); 
      
    }
	}
	
	
	
	
Flux methods -
