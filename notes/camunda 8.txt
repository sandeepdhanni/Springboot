
Camunda 8 is the latest version of Camunda, an open-source workflow and decision automation platform. 

Improved Architecture: Camunda 8 introduces a more modular and flexible architecture, making it easier to integrate with other systems and scale.
Cloud-Native: Designed for cloud environments, Camunda 8 supports containerization and serverless deployment.

difference between camunda 7 and camunda 8:
Integration
REST API (Camunda 7): Camunda 7 provides a REST API for integration.
Improved REST API and Connectors (Camunda 8): Camunda 8 enhances the REST API and adds more connectors for easier integration.
Security
Basic Authentication (Camunda 7): Camunda 7 offers basic authentication mechanisms.
Enhanced Security (Camunda 8): Camunda 8 strengthens security with improved authentication, authorization, and encryption.
Deployment
Traditional Deployment (Camunda 7): Camunda 7 typically deploys on traditional application servers or containers.
Cloud-Native Deployment (Camunda 8): Camunda 8 supports cloud-native deployment on Kubernetes, Docker, and serverless environments.
Architecture
Camunda 7:
Monolithic architecture.
Built around a single, vertically scalable process engine
Camunda 8:
Microservices-based architecture 
Uses Zeebe as its core engine, which is designed for distributed systems.



components in camunda are :
modeler-The Camunda Modeler is a desktop or web-based tool for creating and editing BPMN diagrams that define workflows.

operator- The Operate component is used for monitoring and troubleshooting workflows.
Key features:
Workflow Visualization: Provides real-time visibility into active and completed workflows.
Error Handling: Detects and allows for manual resolution of errors in workflow executions.

tasklist - The Tasklist is an out-of-the-box application that allows end-users to view and manage user tasks assigned to them.
Key features:
User Task Management: Helps users claim, complete, or delegate tasks within a workflow.
Role-Based Access: Tasks are assigned and managed based on roles or users

optimize - The Optimize component focuses on reporting and process improvement.
Key features:
Analytics and Reports: Generates reports based on workflow data to analyze performance.
Dashboards: Provides visual dashboards to monitor key process metrics (KPIs).

connectors - Connectors are pre-built integrations that enable Camunda workflows to interact with external systems.


BPM(business process management):
it is a systematic approach for designing,executing,documenting,monitoring and controlling both automated and non automated process..


BPMN(business process model and notaion) -BPMN is a standardized notation or visual language used to model and represent business 
processes. It is a diagramming standard used to document and design workflows in a way that is understandable by both business 
stakeholders and technical teams.BPMN is a powerful modeling language for simple and complex business processes.

OMG(object management group) - it is responsible for maintainance of bpmn standards..



simulaton token - the simulation token is a concept primarily related to process visualization and testing. It is used to represent
the execution of a business process instance as it moves through the BPMN workflow. The simulation token provides a way to visually 
track the flow of execution during modeling, testing, or debugging of a process, ensuring that the process behaves as expected 
before deployment.



BPMN flow elements:
events - they describe things that happens before or during the end of the process...they can happen regardless of the process or as a
result of the process..u can react to an event or trigger to an events..

tasks - this is an activity that has to be done...

gateways - these are elements that represent multiple possible paths in the process..







zeebe engine :
Zeebe is the heart of Camunda 8 and acts as the core workflow engine. It is a streaming-based, distributed, and event-driven engine 
designed for high scalability and fault tolerance.
BPMN Support: Zeebe supports the Business Process Model and Notation (BPMN) standard for defining workflows.
Event-Driven: It processes workflows as a sequence of events, making it suitable for integrating with event-driven systems (e.g., Kafka).
zeebe is a workflow engine what powers camunda 8.its been newely designed cloud native engine as a 5 yr of research an develoopment.
your business logic lives in worker, microservices that interact with the zeebe engine through a secure grpc gateway and your brokers 
within your zeebe clusters are responsible for executing the bpmn..workers can be implemented in your favourite programming language
as we do have clients for major programming language....zeebe uses a event based architecture that destributes and replicate the run
time state of your process instances over several 

zeebe vs classical engine throughput:
designed to accommodate high throughput use case out of the box.
no relatyional database bottleneck...
linear performance scalling...


 

tasks in camunda 8 -
user task - the user task iis used to define an activity that needs to be completed by human actor...
when the token arrives to the user tasks it will stop at this point and waits until the task is 
completedby human actor..

business rule task - 
it is used to define the evaluation of business rules..those are typically modeled in decision model and notaion(DMN)..
once the decision is made process instance is continues...


manual task - it is used to define the activity that is external to the bpm engine..when u set the task as manuel it means that
the engine does not need to know who will do this activity and there is no known system or user interface..when the token arrives
at this task the process instance will continue automatically..for the engine manual task is handled as pass activity..

service task - it is used to define the automatic execution of that task..typically it represends service task...this means that 
the engine does not execute the task by itself but deligates to different it system...when the token reaches the service task,it 
waits for the external system to complete the task before it continues it


script task- it is used to define the evaluation of script..


send task and receive task - it is used for sending and receiving message..when the token arrives to send task,the process instance 
sends a message to the external system..it is same as service task..
the receiver task referance the message, so the process instanc has to wait here until the proper mesasge is received..



events in camunda 8:
they are flow elements along with tasks and gateways...
tasks - things that has to be done during the process..
gateways - circumstances that lead to different path in the flow...
events - things that is suppose to happen..



start event - shows the event that causes the process to start...this is where the process or subprocess starts...

intermediate events - nothing happens but some state indicate some state archieved in the process..they are espically useful for 
monitoring to understand how the process is doing..

end event - this will end the process....

catching events(passive or start event) - they have a defined trigger : something happened independent of the 
process...the process has to wait for this event or react to it..
catching event may result in :
the process starting


throwing event - 
the event is caused or triggered by the process itself...


timer events -
they are the events triggered by a defined timer..
timer events can be :
1. timer start events- a process can have one or more timer events...each of the timer events must have either a time or date or lifecycle defineation...when a timer is triggered a new peocess is created and the corresponding timer event is activated..
2. intermediate timer catch events - an intermediate timer catch event mush have a time duration that defines
when it defines when it is triggered....


conditional events -
sometimes we only want a process to start or to continue if a certian condition is true..anything can be condition(like the timeer event) can only exist as a catching event..
the conditional event is triggered if a given condition is evaluated to true...

message events - it is used to send or recieve the events..
with the message throw event we send the message..
with the message catch event we have to rely on the sender,so we wait until we receive the message
we have :
message start event and end event
intermediate message catch or throw events



boundary event -
they are the only intermediate catching events that are attached to a task within a process..you wait for them while you do something else in the process...
there are two types in boundary events..they are :
interrupting and non interrupting boundary events

intermediate boundary event - when triggered , they cancel the task.
non interrupting boundary event - when triggered,they create a new token that runs parallel with the initial token..


event based gateway - it is similar to exclusive data based gateway, the event based gateways offers a different way to design process paths...this gateway does not route based on data, but reather by which event takes place next...not all intermediate events combine with the event gateway...you can , however combine it with a receive task..
events are used to model the things that are supposed to happen during a process...events can be catching or throwing....events can be attched to tasks(boundary events,interruptingor non-interrupting)..



signal startevent:

it is just like message event like when u want to trigger some message event u need to send a message name




BPMN participants - 
participant is the entity who controls a single process,or the tasks within a process..this could be :
a person
an organization
a department
a role
participants are represented as pools and lanes ...pools shows who controls the process and lanes are who are responsible for task within it..


pool :
pool represents the participant who controls the single process..it contains all the flow nodes and artifacts that make up to single process..since the process is entirtely contained within the pool sequence flows cannot leave the boundaries of the pool..the pool controls the process flow..besides the task within the process similar to a conductor assign the pieces of a musical score to musicians in an archestra...assignment of tasks within a process is also referred to as orchestration...anytime a new process is created pool is implied in the modeler even though u have not defined it is there by default...1 process=1 pool


lanes :
while the pool behaves like the conductor for the whole process...lanes alos known as swim lanes are like a vaarious musicians in orcastra..each lane defines who or waht is responsible for completing each of the task in the process..lanes can be named according to :
positions or roles within the organization("manager")
General roles("customer,user")
Department("sales,accounting")
applications("crm system")
 each flow object(events,activities,gateways) can only belong to a single lane.
lanes can be useful for clarifying who owns the tasks within a process but they also have some drawbacks the are :
adding multiple lanes to a pool makes the process harder to read..
lanes make it more difficult to change the process down  the line,which increases the maintainance burden..

when to use lanes?
we can use lanes only in stategic process and operational process model..
stategic process model - 
focused on responsibilities and their borders.high level overview(birds eye view),logically abstract,not meant to be executable,avoids complicated events or structures,
operational process model - focused on human workflows.it is low level(worm eye view),logically concrete,coordinates details between human workflow and technical workfloww.can be detailed and complex..



FEEL() -
FEEL (Friendly Enough Expression Language) is a key component in Camunda 8, designed to write expressions that are easily understood by both business professionals and developers. Here are the main points about FEEL:
Purpose: FEEL is used to define expressions in BPMN diagrams, DMN diagrams, and Forms within Camunda 8
Origin: It is specified in the DMN (Decision Model and Notation) specification by the Object Management Group (OMG) 




BPMN message - 
message enables the communication between processes and other systems..messages helps model and understand information is shared and flows between different parts of the overall business process..


choosing between task and event messages -
send messages are active and receive mesages are passive..
tasks- a task emphasizes the action, you can attach several different boundary events to a message task.
events - the event reflects a status,use a message event when : you start a process when a message is received,a message triggers or interrupts the flow..best practice is use a task for sending messages and a event for receiving messages..


orchestration - we have one pool where orchestrator make sure that the task are assigned correctly..in each participant lane.. 


collaboration - each participant orchestrate their tasks which means they are represented in seperate pools..the interaction between them are modeled with message flows..
collapsed pool: shows the different services/processes that are connected to the expanded process.


synchronous adn asynchronous communicartion - receive instant response where as asynchronous means waitin for the response..the sender of the message expects a immediate response from the receiver before proceding to the next activity.....
asynchronous communication  means the sender of the message does not wait for the immediate response from the receiver..the sender can continue with other activitywhile waiting for the response asynchronously...for asynchronmous request response calls u can use send task for the request and the following receiving task or receive message event to wait for the response...




subprocess - 
subprocess is a group of elements or flow nodes that make up a child process used within the large parent process..usually the elements in the subprocess contained within the rounded rectangular similar to a task...
why use subprocesses ? - subprocesses encapsulates complexity processes that represents high level and low level detail at a single heirachy can sometimes be overweling and confusing...subprocesses helps to simplify the process by encapsulating the groups of process elements into their own seperate scope..these groups can be collapse to the size of a task which makes it easier to read the process from the parent level.....subprocesses can also help to modularize and organize your processes..subprocesses allows u to attach events to a specific scope..
there are different types of tasks.they are :
embedded subprocesses
call activity("reusable subprocesses")
transaction subprocesses
ad-hoc subprocesses
event subprocesses



embedded or nested subprocesses - it is contained within an excessable from the parent process....it shares the same set of data from its parent processes...in the parent process it is handled like a task this means that the subprocesses starts when the token arrives from the parent process..this is the only way the subprocess starts..it can't be started from outside such as message event ot timed event...it only begins when the token arrives from the parent process...it stays active as long as any element contained within it is active...when the last element is completed then the subprocess is completed...then the token moves through the outgoing flow and comtinues through the parent processes.. 
note: embedded subprocesses must always have one none start event or start from the none events..


collapse subprocesses - 
they hide the details of the subprocess from the parent view...this is useful when a high level view of a parent process..without reveling the lower level of the subprocess...



call acticity - they are referred to as resuable subprocesses...they contain the same subprocesses,but store in seperate bpmn diagram..they can be shared across teams and managed by multiple team member,which promotes collaboration and distributed ownership,reduces dependencies on any single person or team..they do not inherit data from the parent process..a call acctivity needs data to be passed to it...


BPMN artifacts - it include annotations and groups...they add valuable information to process diagram,it does not effect the flow...artifacts does not effect the sequence flow...


annotations - add descriptive text to diagrams...used to supplement diagrams..should not replace the process documentation...provide insight into the execution of tasks....
purpose of annotations - to provide textual description that can give more context to a model element..annotations serves as a means to add descriptive text or explaination to elements wiithin a BPMN diagram...


groups - they organize elements within our diagram and won't change the sequencial flow...do not influence execution semantics..can be applied across pool boundaries...markoff parts of your models which only certain conventions apply..groups are about the characterization and analytics...they are the visual marker used for organizational purpose and have no impact on the execution..groups are used to visually categorize or cluster elements within a bpmn diagram...


data objects - it represents any kind of data that is relevent for this process instance..data objects should be connected to flow nodes using associations..
purpose of data objects - to indicate where data is needed and how it flows between tasks within the process...represents information that is input into,output from,or transformed within the process...


collection data objects - modification of a regular data object...used when you need to handle multiple instances of the same datatype..


data stores - they are the type of stores that allows data to be persistently stored like a database...they are typically shared and accessed by multiple processes or instances and can be accessed or updated by activities within the process...they provide the mechanism for storing data that persists on the line of the process....data stores are connected to activities through association lines,indicating the flow of data into and out of the store...
purpose of data stores - to show where the data is stored for long ter, access or where multiple process instances might access or update the same data...to indicate the reuse of data across different processes or different instances of the same process...symbolizes a storage location for data that persistes beyond the life of the process....




BPMN error events -
there are cases where error occurs and when that occurs then we have to use error event for handling errors...
error event -
Error events in Camunda 8 are used to handle business errors or technical failures that occur during process execution.
 an error event is a bpmn element represented as a flash symbol..it reacts to an error that occur in an activity such as a task or a subprocess or call activty when it can't complete due to error that you have defined for it..it is considered as serious because it interupts the activity it is attached to which means the processinstance will not continue pass but instead go to another path which u have defined....like other event the error events can be thowing event or a cathching event..the error can be thrown in any activity.....
in order to model the error expecitly in your process..we would use a throw event...error throw event modeled as an end event for a subprocess or call activity and typically it include the 

when to use error events -
when the activity cannot be completed..and the error happens during activity execution,requires a business reaction,occurs offen and repeatedly...

note : be selective when modeling error events so that your process remains uncluttered..


Error catch events :
An Error Catch Event is used to catch an error thrown within a process and take corrective action.
Types of Error Catch Events:
Error Boundary Event (Attached to a Task or Subprocess)
Placed on the boundary of a BPMN task or subprocess.
Interrupts the task/subprocess if an error occurs.
Redirects the process to an alternative path.
Error Start Event (Inside an Event Subprocess)
Triggers a new event subprocess when a specific error occurs.
Can handle errors globally within the scope of the main process.


Error throw events :
An Error Throw Event is used to explicitly signal that an error has occurred.it is an active event to throw an error..
Types of Error Throw Events:
Error Intermediate Throw Event
Used within a process to indicate an error.
The thrown error must be caught by an error catch event.
Error End Event
Ends the process abnormally by throwing an error.
Can be caught by an Error Boundary Event or an Error Start Event.




escalation events :
Escalation events in Camunda 8 are used to signal a non-critical issue that needs attention but does not terminate the process. Unlike Error Events, which indicate failures, Escalation Events allow a process to handle exceptional situations while continuing execution.it is a bpmn element which is represented as a upward symbol..it is used for communication between parent and subprocess levels(vertical communication)..unlike other events escalation events are non critical because they don't necessarily interupt the process..they indicate that information needs to be send to a higher scope level in the process...unlike error events escalation events can be thrown and caught..



DMN(decision management and notation) - 
it is a standard notation developed by object management group(OMG) and widely used in different industries....DMN defines the desicion logic in a visual way,working alongside BPMN...in DMN,decision means derive a result(output) from given facts..

DRD(decision requirement diagram) - they are visualize as disicion requirement diagram..when starting to model a decision it is important to start with drd because it defines with the structure of the decision....it is a dmn notation that allows for the definition of complex decisions.drd's contain :
decision - the act of determining an output value from the number of input values,using logic decision
input data - the input data that you feed into your decision logic in order to determinethe output value..
relations between decisions - you can connect decision with arrows and therefoew indicate which decision output will be considered as an input for another decision...

Each line in the decision table represents a rule...a rule consists of an input expression and an output expression..if the input expression returns true,then the corresponding output will be returned...


Business rule task - it is used to model the evalution of business rule,for example, a decision modeled in decision model and notation..

hit policies in dmn - 
it describes different ways to evaluate the rules conatained in a decision table..different policies do not only lead to different result, but typically also requires different modes of thinking and reasoning about the meaning of the entire decision table...the unique hit poolicy returns a single result...two rules cannot overlap and evaluate to true at the same time...in our decision table,the forth rule overlaps with other rulles and therefore prevents us from using the unique hit policy...the hit policy first evaluates the rules from top to bottom and returns the first rule that evaluates as true..










decision logic - it defines the roles in the decision..the most common way to model the decision logic is by decision table..
dmn comes with its own expression logic feel(friendly enough expression language)...with both drd(decision requirement diagram) and decision logic it is easy tho define the logic of the decision..



FEEL(friendly enough expression language) - it is the part of th4e DMN specification of the object management group..it is designed to write the expression for decision table and literal expressions in a way that is easy top understand business professionals and developers..everything begins with datatypes and it has several datatypes..
string - this is a text value ,a sequence of characters enclosed in double quotes..eg: "audi"
number - this can be any kind of number like integer(1) or floats(2.34)..the numbver can be negative...
boolean -this can have only two values - true and false..
Date - 
A date value without a time component.
Format: yyyy-MM-dd.
Java Type: java.time.LocalDate
date("2017-03-10")
eg: @"2017-03-10"
Time -
A local or zoned time. The time can have an offset or time zone id.
Format: HH:mm:ss / HH:mm:ss+/-HH:mm / HH:mm:ss@ZoneId
Java Type: java.time.LocalTime / java.time.OffsetTime
time("11:45:30")
Date-time - 
A date with a local or zoned time component. The time can have an offset or time zone id.
Format: yyyy-MM-dd'T'HH:mm:ss / yyyy-MM-dd'T'HH:mm:ss+/-HH:mm / yyyy-MM-dd'T'HH:mm:ss@ZoneId
Java Type: java.time.LocalDateTime / java.time.DateTime
date and time("2015-09-18T10:31:10")
Days-time-duration -
A duration based on seconds. It can contain days, hours, minutes, and seconds.
Format: PxDTxHxMxS
Java Type: java.time.Duration
duration("P4D")
Years-months-duration
A duration based on the calendar. It can contain years and months.
Format: PxYxM
Java Type: java.time.Period
duration("P2Y")
List -
A list of elements. The elements can be of any type. The list can be empty.
Java Type: java.util.List
[]
[1,2,3]
["a","b"]
Context -
A list of entries. Each entry has a key and a value. The key is either a name or a string. The value can be any type. The context can be empty.
Java Type: java.util.Map
{}
{a:1}
{b: 2, c: "valid"}


unary-tests in feel -
unary tests is a special kind of boolean expression..it should be used for input entries of decision table(i.e the condition of a rule)
A unary-tests expression returns true if one of the following conditions is fulfilled:
The expression evaluates to true when the input value is applied to the unary operators.
The expression evaluates to true when the input value is assigned to the special variable ?.
The expression evaluates to a value, and the input value is equal to that value.
The expression evaluates to a list, and the input value is equal to at least one of the values.
The expression is equal to - (a dash).
Comparison
Compares the input value with a given value. The input value is passed implicitly as the first argument of the operator.
Both values must be of the same type. Otherwise, the result is null.
Operator	Description	Supported types
(none)	equal to	any
<	less than	number, date, time, date-time, duration
<=	less than or equal to	number, date, time, date-time, duration
>	greater than	number, date, time, date-time, duration
>=	greater than or equal	number, date, time, date-time, duration


Interval -
Checks if the input value is within a given interval between x and y.
An interval has two boundaries that can be open (x..y) / ]x..y[ or closed [x..y]. If a boundary is closed, it includes the given value (i.e. less/greater than or equal). Otherwise, it excludes the value (i.e. less/greater than).
The input value is passed implicitly to the operator.
(2..5)
// input > 2 and input < 5

]2..5[
// input > 2 and input < 5

[2..5]
// input >= 2 and input <= 5

(2..5]
// input > 2 and input <= 5

Disjunction/or -
Combines multiple unary-test expressions following the ternary logic.
Returns true if at least one unary-test evaluates to true.
Otherwise, it returns false.
2, 3, 4
// input = 2 or input = 3 or input = 4
< 10, > 50
// input < 10 or input > 50

Negation/not -
Negates a given unary-test expression. The expression can be a comparison, an interval, or a disjunction.
It returns true if the given unary-test evaluates to false.
not("valid")
// input != "valid"
not(2, 3)
// input != 2 and input != 3


https://docs.camunda.io/docs/components/modeler/feel/language-guide/feel-boolean-expressions/
this url contain the docs about the feel expression


expressions - general expression that can return values of different types..they can uesd everywhere..



Manual task - 
it is an external to zeebe engine..it is used to model work done by somebody who the engine does not know of that and that has unknown system or ui interface...it is also considered as  a pass through activity,automatically continuing when the process execution arrives at it..


camunda forms -
they are used to create camunda forms using moduler...they are used in conjunction with user tasks and can be displayed in tasklist..they will be going through the three different nodes...they are : code editor mode,validate mode,design mode
design mode - which is used for designing the form..this si the default mode where we create a new form..there are three section in form..they are
 components,form defination and form preview..
in components we have input,selection,presentation,containers and action..
in form definition u build the visual aspect of your form in the form defination section..

form preview - 
in form preview you interact with a form and see how it looks and behaves with mock data that simulates what an end user sees in tasklist...
in form preview we have disabled and read only where disabled means any data in the field will not be submitted with the form and will not be seen where as read only will have data where we can only read 
fx in form preview - it means the field can be use as a feel expression..


validate mode - which is used for testing
code editor mode -  which is used to see the code..


milestones functoionality - 
shows the milestones that you set for the form..



components -
components are the elements that make up a form and define its structure...
input section - these elements allow you to display and/or manually enter data into the form..
text field - this is used to display,modify or create data stored in a process variable..
selection catagory -this allows the user of the form to make choices that will altimately change the data related to the form..

note : the options can be created statically and dynamically voted from the input data.....

presentation section -
this will help u display data headings or any other data in the form..these elements are typically read only...

container section - this section allows u to group elements together or in the case of iframe embed external content into your form..

action element - we will use this to either trigger a form submssion or reset the form itself....

field element - this typically serves as a heading or title for the field itself...
field description - this will allows u to add additional details..
key field - this refers to the data this element is interacting with..if u change the value in the text field it modifies the value stored in the process variable....in this way you can read and write to a process variable through form element..
disabled button - this element can still be edited but the data in the field will not be submitted...
default value - you can create default value which allows the elements to use a specific value..until one is written or choosen..
custom properties - this will allow you to set the property value that can be used in the execution of the swarm.. this is often used by custom task list implementaions to customize the form..




script task -
it is used to model the evaluation of a script..


expanded subprocesses - 
this is a embedded subprocesses that allows you to group elements of the process..


call activity - 
a call activity allows you to call and invoke another process as part of this process...the subprocess is externalized (stored as seperate bpmn diagram) and can be invoked by different processes...



TIMER EVENT - 
it is used to initiate the process instance periodically or pause it for a specific duration of time..
date- it is used to start a new process instance at a certain date/time...
cycle - it is used to start a new process instance at a certain time,such as every 2 hours..
eg: R/PT2H - Repetition/Period Time 2 Hours



MLTI-INSTANCE MARKER -
WHEN TO USE -
manage iterations in a business process
execute a task or a process several times..
TYPES OF MULTI-INSTANCE MARKERS:
sequencial-instance marker
parallel-instance marker
multi-instance markers can be used with different task types.. 

paralle instance -
in case of parallel instance activity,all instances are created when the multi-instancebody is activated..the instances are executed concurrently and independently from each other..
in parallel instance we have completion condition which terminates the multi-instance in advance if a condition occurs...
we have input collection in multi-instance where we define a variable where this variable will be evaluated and the task instance will be createdfor each element in the collection..
we have input element variable will be populated with the values from the collection..
we have output collection will contain the aggregate result of each individual vote which is defined in the output element property..  






FRIENDLY ENOUGH EXPRESSION LANGUAGE(FEEL) OVERVIEW -
FEEL is a expression language designed to write expressions in a way that both business professionals and developers can easily understand it...FEEL is executed by engines...FEEL is part of the decision model and notation(DMN) standard...
FEEL is designed to have:
simple syntax designed for a wide audience and executablle by engines..
simple data model with JSON-like types:number,dates,strings,lists, and context...
three-valued logic(true,false,null)

FEEL defines several data types that you can use to represent different kinds of valueswithin expression..
data types provide a framework for representing various kinds of data,from simple values like number and strings to more complex structures like lists and contexts...they dictate how we interact with data,influencing operations,constraintts,and within decision models....

NULL - (nothing,null,or nil(the value is not present))
	FEEL follows one simple rule:if something goes wrong,return null....
if the expression camnnot be evaluated successfully it returns null 
NUMBER - 
       a whole or floating point number...the number can be negative...not-a-nuber(NaN),positive/negative infinity are represented as null...example of expressions based on number datatype: addition,substraction,multiplication,etc...additional expression:2+3

SEQUENCE - 
         sequence of characters enclosed in double quotes "....the sequence can also contain escaped charaxcters starting  with /....eg : \'l,\",\r,\t,unicode like \u269D or  \u101EF

BOOLEAN -
        a boolean value...it can be either true or false...

DATE -
a date value without a time component...format:yyyy-mm-dd....eg:date("2024-06-06")



ADDITIONAL FEEL DATA TYPES -
temporal data types and complex data types play a pivotal roles in decision modeling..
temporal data types are crucial for scenarios involving time-sensative decisions or events...
temporal data include :  time,date-time,days-time-duration,years-months-duration
format: PxDtXhXmXs
eg : date("2024-04-06")+duration("P1D")   //date("2020-04-07")

complex data types empower modelers to organize and manage intricate data structures,such as nested lists and key-value pairs,essential for capturing complex business logic and relationships... .complex data types include : 
context - context is a list of entries..each entry has a key and a value...the kety is either a name or a string..the value can  be any type..eg : [1,2,3,4]


BASIC FEEL OPERATORS - 
they are calculation operators,comparison operators,logical operators..
CALCULATION OPERATORS - 
they are Addition(+),Subtraction(-),Multiplication(*),Division(/),Exponentiation(**)

COMPARISON OPERATOR - 
they are Equal to(=),not equals to (!=),greater than(>),less than(<)

IMPORTANT : the equals operator has only one equals sign....eg : x=y


LOGICAL OPERATOR - 
they are and,or



FEEL BUILD-IN FUNCTIONS - 
FEEL comes with set of build-in functions that enable u to manipulate data,perform calculations, and make decision....
some build-in functions are :
upper case(string): convert a string to uppercase
contains(string,match) : check if a string contains a specified substring..eg:contins("I know FEEL","FEEL")
round(number) : rounds a number to the nearest integer
random number() : generates a random number between zero and one
today() : obtains the current date without any time component..eg:2025-02-06



WHERE CAN YOU USE FEEL :
you can use feel in 
BPMN diagram -in script task,gateway conditions
DMN diagram - in decision tables,literal expressions
camunda forms - element properties,templating syntax.

FEEL IN SCRIPT TASK - 
when the process instance arrives at a script task,the integrated FEEL scala engine evaluates the script task FEEL expression..once the FEEL expression is evaluated successfully,the process instance continues..if the FEEL expression is unsuccessful,an incident is raised at the script task..when the incident is resolved,the script task is evaluated again...
To configure a script task with an inline FEEL expression,perform the following steps:
1. define the feel expression inside the expression attribute...
2.Define the name of the process variable in the resultVariable attribute..this variable will store the result of the feel expression evaluation...


FEEL IN EXCLUSIVE GATEWAY - 
when an exclusive gateway is entered,the conditionExpression is evaluated.the process instance takesthe first sequence flow where the condition is fulfilled..
if no condition is fulfilled,it takes the default flow of the gateway..if the gateway has no default flow,an incident is created.....A condition defines when a flow is taken..it is a boolean expression that  can access the process instance variables and compare them with literals or other variables.the condition is fulfilled when the expressionreturns true..Multiple boolean valuesor comparisions can be combinedas disjunction(or) or conjunction(and)...

FEEL IN DECISION TABLE - 
An input expression specifies how the value of the input clause is generated.it is usually simple and references a variable which is available during the evaluation..the expression is set inside a text element that is a child of the inputExpression XML element..
An input entry contains a unary-test in a text element as child of an inputEntry XML element..the input entry is satisfied when the evaluated expression returns true...


FEEL IN LITERAL EXPRESSION - 
A decision literal expression represents decision logic which can be depicted as an expression..it consistes of a literal expression and a variable..
A decision literal expression is represented by a literalExpression inside a decision XML element..The literal expression  specifies how the value of the decision is generated.it can be used to do a complex calculation,or to combine the output values of the requred decision...

FEEL IN ELEMENT PROPERTY :
A form configuration starts off as a composition of form elements to define the structure..the specific behaviors are then defined as properties on the individual form elements through the properties panel....
the literal expression specifies how the value of the decision is generated..it can be used to do a complex calculation,or to combine the output values of required decision...

FEEL in templating syntax - 
templated properties configuration allows for dynamic content creation within forms using a templating languagecalled feelers..
FEELERS SYNTAX :
VARIABLES/INSERTS : to insert a variable,use double curly braces{{variable}}, and the value of this variable will be inserted..we can use any valid FEEL expression within double braces..
iterating through arrays
conditional sections
additional details





Understand the basic temporal data types:
date
time
date and time
day-time duration
year-month duration
Operate with various temporal expressions:
Addition
Subtraction
Multiplication
Division
Recognize most common temporal attributes:
year, years
month, months
day, days
weekday
hour, hours
minute, minutes
second, seconds
time offset
timezone
Use various temporal functions:
now()
today()
day of week()
day of year()
week of year()
month of year()
last day of month()







FEEL TEMPORIALS :
ADDITION - 
In this lesson, we will explore how to perform addition operations between different data types in DMN FEEL. We will cover:
Adding durations to dates
Adding durations to times
Adding durations to date and time
Adding durations to durations
By practicing these operations, you will become proficient in handling various date, time, and duration manipulations in your decision models using FEEL.
Date
Info
DATE + DURATION = DATE
When you add a duration to a date, you adjust the date by the specified period.
Adding a day-time duration to a date
date("2025-01-01") + duration("P10DT24H2M")
Result: "2025-01-12"
Adding a year-month duration to a date
date("2025-01-01") + duration("P2Y3M")
Result: "2027-04-01"
Time
Info
TIME + DURATION = TIME
When you add a duration to a time, you adjust the time by the specified period.
Adding hours and minutes to a time
To add hours and minutes, you can combine different duration parts. For example, adding 1 hour and 45 minutes:
time("14:30:00") + duration("PT1H45M")
Result: "16:15:00"
Date and time
Info
DATE-TIME + DURATION = DATE-TIME
When you add a duration to a date and time, you adjust both the date and the time by the specified period.
Adding a year-month duration to a datetime
date and time("2025-01-01T14:30:00") + duration("P1Y3M")
Result: "2026-04-01T14:30:00"
Adding a day-time duration to a datetime
date and time("2025-01-01T14:30:00") + duration("P3DT4H5M6S")
Result: "2025-01-04T18:35:06"
Duration
Info
DURATION + DURATION = DURATION
Adding duration to duration
The two arguments of the expression must have a day-time or a year-month duration.
duration("P2D") + duration("P5D")
Result: "PT168H"
Null result
The addition of these different data types will return null:
DATE + DATE = NULL
TIME + TIME = NULL
TIME + DATE = NULL
DURATION(YM) + DURATION(DT) = NULL




















CAMUNDA FEEL ENGINES -
To evaluate the expression,camunda employs two distinct FEEL engines:
FEEL scala : it is a java based FEEL engine integrated into the backend of camunda 8..it is primarily responsible for evaluating expressions in BPMN diagrams and DMN tables..
Feelin : it is a javascript-based FEEL engine designed for use in the browser and used for camundaforms and templating...
note: camunda extensions are currently not supported by feelin...


CAMUNDA FEEL TEMPORIALS :

Understand the basic temporal data types:
date
time
date and time
day-time duration
year-month duration
Operate with various temporal expressions:
Addition
Subtraction
Multiplication
Division
Recognize most common temporal attributes:
year, years
month, months
day, days
weekday
hour, hours
minute, minutes
second, seconds
time offset
timezone
Use various temporal functions:
now()
today()
day of week()
day of year()
week of year()
month of year()
last day of month()






FEEL LISTS :
Operate with various list expressions:
Get - To access an element in a list, you use the index notation.
["Mercury", "Venus", "Earth", "Mars"][1]


Filter
Some
Every
Use various number list functions:
min() and max() -
The min() and themax() functions in ðŸ”—FEEL used in Camunda are used to find the smallest and largest values in a list, respectively.
// Syntax
min(list)
max(list)
min([0, -10, -20, 5, 15])
max([date("2023-01-01"), date("2022-06-15"), date("2024-03-10")])
	

sum() and product() -
The sum() and theproduct() functions in ðŸ”—FEEL used in Camunda are used to calculate the sum and the product of the elements in a list, respectively.
// Syntax
sum(list)
product(list)
sum([1, 2.5, 3.5, -3])


mean(), median(), and stddev() -
The mean() , themedian(), and the stddev() functions in ðŸ”—FEEL used in Camunda are used to calculate the average (arithmetic mean), the median (middle value), and the standard deviation (the amount of variation or dispersion) of the elements in a list, respectively.
// Syntax
mean(list)
median(list)
stddev(list)
mean([1, 2.5, 0.5, -4])
median([1, 2, 3, 4, 5, 6])
stddev([1, -2, 3, -4, 5])


mode() -
The mode() function in ðŸ”—FEEL used in Camunda is used to determine the number(s) that appear most frequently in a list. If there are multiple numbers with the same highest frequency, it returns all of them. It returns a list of elements.
// Syntax
mode(list)
mode([1, 2, 2, 3, 4])
mode([1, 1, -2, -2, 3, 4])


Use various general list functions:
list contains() -
The list contains() function in ðŸ”—FEEL used in Camunda is used to check if a list contains a specific element. It returns a boolean value.
// Syntax
list contains(list, element)
list contains([1, 2, 3, 4, 5], 3)


count() -
The count() function in ðŸ”—FEEL used in Camunda is used to determine the number of elements in a list. It returns a number.
// Syntax
count(list)
count([1, 2, 3, 4, 5])
count([5, 10, 15, 20, 25][item < 20])


all() and any() -
In FEEL (Friendly Enough Expression Language) used in Camunda, the all() and any() functions work with lists and logical conditions. They are contrary in the sense that:
all(condition, list) â†’ Returns true if all elements in the list satisfy the given condition.
any(condition, list) â†’ Returns true if at least one element in the list satisfies the given condition.
Using all()
all(x > 5, [6, 7, 8])  // true (all elements are > 5)
all(x > 5, [6, 4, 8])  // false (4 is not > 5)
Using any()
any(x > 5, [6, 7, 8])  // true (at least one element > 5)
any(x > 5, [3, 4, 5])  // false (no element is > 5)	


sublist() -
The sublist() function in ðŸ”—FEEL used in Camunda is used to extract a portion of a list based on specified start postion and lenght indexes.
// Syntax
sublist(list, start position, length)
Returns a partial list of the given list starting at start position, of a given length (optional).
The start position starts at the index 1. The last position is -1.
Get the next 2 elements from position 1
sublist(["Mars","Earth","Mercury"], 1, 2)
Result: ["Mars","Earth"]


append(), insert before(), and remove() -
In this lesson, we will cover the append(), insert before(), and the remove() functions in ðŸ”—FEEL used in Camunda.
append(): Returns the given list with all items appended
The parameter items can be a single element or a sequence of elements
insert before(): Returns the given list with newItem inserted at position
remove(): Returns the given list without the element at position
// Syntax
append(list, items)
insert before(list, position, newItem)
remove(list, position)
append(["onions","tomatoes"],"garlic","pepper")
insert before(["onions","tomatoes"], 2, "garlic")
remove(["onions","tomatoes"],2)


reverse() and index of() -
In this lesson, we will cover the reverse() and the index of() functions in ðŸ”—FEEL used in Camunda.
reverse(): Returns the given list in reverse order
index of(): Returns a list with the index(es) of the occurrence(s) of a specified element in the list.
If the element is not found, it returns an empty list []
// Syntax
reverse(list)
index of(list, element)
reverse([10, 20, 30, 40, 50])
index of([10, 20, 30, 40, 50], 30)
Result: [3]



union(), distinct values(), and duplicate values() -
In this lesson, we will cover the union(), distinct values(), and the duplicate values() functions in ðŸ”—FEEL used in Camunda.
union(): Returns a list containing all the elements from the input lists, without any duplicates
distinct values(): Returns a list containing only the distinct (unique) values from the input list
duplicate values(): Returns a list containing only the duplicate values from the input list.
// Syntax
union(lists)
distinct values(list)
duplicate values(list)
union([1, 2, 3, 4],[3, 4, 5])
distinct values([1, 2, 2, 3, 4, 4, 5])
duplicate values([1, 2, 2, 3, 4, 4, 5])


sort() -
The sort() function in ðŸ”—FEEL used in Camunda defines the sorting order using a custom precedes function. This advanced feature allows you to sort lists based on custom criteria.
// Syntax
sort(list, precedes: function<(Any, Any) -> boolean>)
list: The list to be sorted.
precedes: A custom function that defines the sorting order. It takes two arguments and returns a boolean indicating whether the first argument should precede the second.
sort([3, 1, 4, 5, 2], function(x,y) x > y)
Result: [5, 4, 3, 2, 1]
Sort the list ["pear", "plum", "apple", "banana"] by the second character of each string. You can use the substring() function.
sort(["pear", "plum", "apple", "banana"], function(x, y) substring(x, 2, 1) < substring(y, 2, 1))


flatten(), concatenate(), and string join() -0
In this lesson, we will cover the flatten(), concatenate(), and the string join() functions in ðŸ”—FEEL used in Camunda. These functions help in manipulating lists and strings for various purposes in decision models.
flatten(): takes a nested list and merges the elements into a single list
concatenate(): Concatenates multiple lists into a single list
string join(): Joins the strings of a list into a single string, with an optional delimiter between elements and/or an optional prefix or sufix
// Syntax
flatten(nested list)
concatenate(lists)
string join(list, delimiter, prefix, suffix)
flatten([[1, 2, 3], [4, 5], [6, 7, 8]])
Result: [1, 2, 3, 4, 5, 6, 7, 8]
concatenate([1, 2], [3, 4], [5, 6])
Result: [1, 2, 3, 4, 5, 6]
string join(["Camunda", "FEEL", "is", "great"], " ")
Result: "Camunda FEEL is great"
Build a paragraph in HTML (<p> tag) to display the colors of this list separated by comma ",": ["red","yellow","blue","green"]
string join(["red","yellow","blue","green"], ", ", "<p>", "</p>")  
Result: "<p>red, yellow, blue, green</p>"





FEEL CONTEXTS -
Understand the basic context data type
Operate with various context expressions:
Access the context
Filter a list of context elements
Project a list of context elements
Use various general context functions:
get value()
get entries()
context put()
context merge()


CONTEXT -
A context data type is a powerful feature that allows you to define and manipulate collections of key-value pairs:
key: is a string. Refer to the ðŸ”—Variable Names Conventions for valid key names.
value: can be any FEEL data type, including numbers, strings, booleans, lists, other contexts, and FEEL expressions.
NOTE : This context input will only accept a JSON object.
Otherwise, we will simply create the context through an expression directly, so the "context input" will be empty "{}"
Creating a context data type
To create a context data type in FEEL, you enclose the elements within curly braces {}.
// empty context
{}
// context example
{
  "firstName": "John",
  "lastName": "Doe",
  "age": 25,
  "isEmployed": true,
  "address": {
    "street": "Main Street",
    "city": "Metropolis"
  },
  "scores": [80, 85, 90],
  "resultScores": sum(scores)
}
Creating a context using an expression
A context data type can also be created through an expression in a similar way.
When using an expression to create a context, keys can be either a name or a string.
Reminder: context input accepts only a JSON object, so you can only use string values for the keys.
The expression will look like this with names as keys:
{
  "person": {
    "name": "Alice",
    "birthday": "1981-03-04",
    "age": now().year - date(birthday).year
  }
}
Result:
{
  "person": {
    "name": "Alice",
    "birthday": "1981-03-04",
    "age": 43
  }
}

context expressions in FEEL. We will cover:
Accessing the context
Filtering a list of context elements
Projecting a list of context elements

ACCESSING THE CONTEXT :
To access values in a provided context data, use the dot notation in your expression.
{
  "person": {
    "name": "Alice",
    "age": 30
  }
}
person.name
Result:
"Alice"

FILTERING A LIST OF CONTEXT ELEMENTS -
You can filter a list of context elements based on a condition using a filter expression.
Get the context elements where age is greater than 18
[
  {
    name: "Jane",
    age: 22
  },
  {
    name: "William",
    age: 16
  }
][age > 18]
result :
[
  {
    "name": "Jane",
    "age": 22
  }
]
PROJECTING A LIST OF CONTEXT ELEMENTS -
You can project a list of context elements based on the their key.
Project the name of the context elements
[
  {
    name: "Jane",
    age: 22
  },
  {
    name: "William",
    age: 16
  }
].name
Result:
[
  "Jane",
  "William"
]



GET VALUE() - 
The get value() function in ðŸ”—FEEL used in Camunda is used to retrieve a value from a context based either on a single key or a list of keys to provide the path to the value. This function is particularly useful when dealing with simple and nested contexts or when you need to dynamically access values.
// Syntax
get value(list, key)
get value(list, keys list)
The expression returns null for any attempt to retrieve a value using non-existent keys.
get value({color: "green"}, "color")
Result:
"green"
Retrieve a nested context key
{
  "company": {
    "name": "Camunbankia",
    "offices": {
      "headquarters": {
        "city": "Neverland",
        "address": {
          "street": "5th Avenue",
          "number": 123
        }
      }
    }
  },
  "streetName": get value(company, ["offices", "headquarters", "address", "street"])
}.streetName
Result:
"5th Avenue"

Use the dynamic key list stored in keyPath to retrieve the value from the settings context:
{
    "settings": {
        "theme": "dark",
        "preferences": {
            "notifications": {
                "email": "info@camunbankia.com",
                "sms": 4567
            }
        },
        "keyPath": ["preferences", "notifications", "email"]
    }
}
get value(settings, settings.keyPath)
Result:
"info@camunbankia.com"

GET ENTRIES() -
The get entries() function in ðŸ”—FEEL used in Camunda is used to retrieve all key-value pairs from a context as a list of entries. Each entry is represented as a context with keys "key" and "value".
// Syntax
get entries(context)
{
  "employee": {
    "id": 1001,
    "name": "Alice",
    "position": "Engineer"
  },
  "entries": get entries(employee)
}.entries
Result:
[
  {
    "key": "id",
    "value": 1001
  },
  {
    "key": "name",
    "value": "Alice"
  },
  {
    "key": "position",
    "value": "Engineer"
  }
]



CONTEXT PUT() -
The context put() function in ðŸ”—FEEL used in Camunda allows you to add or update a key-value pair in a context. It returns a new context that includes the entry. This function is particularly useful for dynamically modifying contexts during decision-making processes.
A list of 2 keys will define the path of the entry to add or update nested contexts:
If keys contains the keys [k1, k2] then it adds the nested entry k1.k2 = value to the context
If an entry for the same keys already exists in the context, it overrides the value.
// Syntax
context put(context, key, value)
context put(context, 2 keys, value)
{
  "person": {
    "name": "Peter",
    "age": 30
  },
  "updatedPerson": context put(person, "city", "New York")
}.updatedPerson
Result :
{
  "name": "Peter",
  "age": 30,
  "city": "New York"
}
Modify a simple entry
{
  "person": {
    "name": "Peter",
    "age": 30,
    "city": "New York"
  },
  "updatedPerson": context put(person, "age", 31)
}.updatedPerson
Result:
{
  "name": "Peter",
  "age": 31,
  "city": "New York"
}
Add a 2 keys entry
{
    "book": {
        "title": "1984",
        "author": "George Orwell"
    }
}
context put(book, ["publication","year"], 1949)
Result:
{
  "author": "George Orwell",
  "title": "1984",
  "publication": {
    "year": 1949
  }
}

CONTACT MERGE() -
The context merge() function in ðŸ”—FEEL used in Camunda is useful for consolidating data from a list of contexts or for enriching an existing context with additional information.
// Syntax
context merge(context list)
{
  "context1": {
    "name": "Alice",
    "age": 30
  },
  "context2": {
    "city": "New York",
    "age": 31
  },
  "mergedContext": context merge(context1, context2)
}.mergedContext
Result:
{
  "name": "Alice",
  "age": 31,
  "city": "New York"
}
Merge context1 and context2, and observe how duplicate keys are handled.
{
    "context1": {
        "employeeId": 123,
        "name": "Emily",
        "department": "HR"
    },
    "context2": {
        "name": "Emma",
        "age": 28,
        "department": "Finance"
    }
}
Expression:
{
    "context1": {
        "employeeId": 123,
        "name": "Emily",
        "department": "HR"
    },
    "context2": {
        "name": "Emma",
        "age": 28,
        "department": "Finance"
    },"mergedContext": context merge(context1,context2)
}.mergedContext
Result :
{
  "employeeId": 123,
  "name": "Emma",
  "department": "Finance",
  "age": 28
}

context you will be working with:
{
  "teachers": [
    {
      "name": "John Doe",
      "yearsOfExperience": 5,
      "skills": {
        "Classroom Management": "Intermediate",
        "Curriculum Development": "Basic",
        "Mathematical Analysis": "Expert"
      }
    },
    {
      "name": "Jane Smith",
      "yearsOfExperience": 7,
      "skills": {
        "Literary Criticism": "Expert",
        "Creative Writing": "Intermediate",
        "Public Speaking": "Basic"
      }
    },
    {
      "name": "Emily Johnson",
      "yearsOfExperience": 4,
      "skills": {
        "Lab Safety": "Intermediate",
        "Biology Research": "Basic",
        "Student Engagement": "Intermediate"
      }
    },
    {
      "name": "Michael Brown",
      "yearsOfExperience": 10,
      "skills": {
        "Historical Research": "Expert",
        "Archival Studies": "Expert",
        "Lesson Planning": "Intermediate"
      }
    },
    {
      "name": "Jessica Garcia",
      "yearsOfExperience": 3,
      "skills": {
        "Chemical Analysis": "Basic",
        "Safety Procedures": "Intermediate",
        "Problem Solving": "Basic"
      }
    },
    {
      "name": "William Martinez",
      "yearsOfExperience": 6,
      "skills": {
        "Physical Fitness": "Expert",
        "Sports Coaching": "Intermediate",
        "Team Building": "Intermediate"
      }
    },
    {
      "name": "Sarah Wilson",
      "yearsOfExperience": 9,
      "skills": {
        "Artistic Expression": "Expert",
        "Design Fundamentals": "Intermediate",
        "Art History": "Basic"
      }
    },
    {
      "name": "Brian Anderson",
      "yearsOfExperience": 8,
      "skills": {
        "Theoretical Physics": "Expert",
        "Experimental Design": "Intermediate",
        "Quantitative Analysis": "Expert"
      }
    },
    {
      "name": "Nancy Davis",
      "yearsOfExperience": 2,
      "skills": {
        "Music Theory": "Intermediate",
        "Instrumental Skills": "Basic",
        "Performance Techniques": "Basic"
      }
    },
    {
      "name": "David Miller",
      "yearsOfExperience": 11,
      "skills": {
        "Programming": "Expert",
        "Algorithm Design": "Expert",
        "Cybersecurity": "Intermediate"
      }
    }
  ]
}
Task
Get the context skills from the senior teachers (with at least 10 years of experience)
teachers["yearsOfExperience" >=10 ].skills





RECAP OF BASIC CONDITIONALS -
 
A simple conditional in FEEL evaluates a condition and returns a result based on whether the condition is true or false.
Syntax:
if condition then result1 else result2
Example:
if order.totalAmount > 50 then "Free Shipping" else "Standard Shipping"

Nested Conditionals -
Nested conditionals are conditionals within conditionals. They allow for more complex decision logic by evaluating multiple conditions in a hierarchical manner.
Syntax -
if condition1 then
  if condition2 then result1 else result2
else
  if condition3 then result3 else result4
Example:
Determine the discount based on customer type and order amount:
if customer.isPremiumMember then
  if order.totalAmount > 100 then 20 else 10
else
  if order.totalAmount > 100 then 5 else 0

Using Logical Operators -
Logical operators (and and or) allow for combining multiple conditions into a single conditional statement.
AND Operator
Evaluates to true if all conditions are true.
if condition1 and condition2 then result1 else result2
Example :
if order.totalAmount > 50 and customer.isPremiumMember then "Free Shipping" else "Standard Shipping"

OR Operator -
Evaluates to true if at least one condition is true.
if condition1 or condition2 then result1 else result2
Example :
if order.totalAmount > 50 or customer.isPremiumMember then "Free Shipping" else "Standard Shipping"

NOT Operator -
Reverses the boolean value of a condition.
if not(condition) then result1 else result2
Example :
if not(customer.isPremiumMember) then "Standard Shipping" else "Free Shipping"
Examples :
{
  "customer": {
    "loyaltyPoints": 550,
    "isFirstOrder": false,
    "age": 23,
    "isStudent": true,
    "isMember": false,
    "isPremiumMember": true
  },
  "order": {
    "totalAmount": 250,
    "isGift": false
  },
  "user": {
    "role": "Manager",
    "department": "Sales"
  }
}
Grant user access
Write a FEEL expression to determine the level of access a user should have based on their role and department. The levels are:
Admins in any department: "Full Access"
Managers in Sales: "Sales Access"
Managers in other departments: "Limited Access"
All other roles: "No Access"
if user.role = "Admin" then "Full Access"
else if user.role = "Manager" then
  if user.department = "Sales" then "Sales Access"
  else "Limited Access"
else "No Access"
Result:
"Sales Access"
Write a FEEL expression to add a new element to the customer following this rules:
category will be "Adult" if the age is greater than 18
otherwise, category will be "Minor"
{
  "category": if customer.age > 18 then context put(customer, "category", "Adult") else context put(customer, "category", "Minor")
}.category
Result:
{
  "isFirstOrder": false,
  "isStudent": true,
  "category": "Adult",
  "isPremiumMember": true,
  "loyaltyPoints": 550,
  "isMember": false,
  "age": 23
}




LOOPS AND ITERATIONS -
In FEEL, the primary looping construct is the for loop, which can be used to iterate over a collection of items, performing operations on each item. This is particularly useful for processing lists.
Using for Loops :
for element in list return expression
Example: Suppose you have a list of prices and you want to apply a 10% discount to each price:
for price in [100, 200, 300] return price * 0.9
Output:
[90, 180, 270]
Examples :
Applying Discounts to Prices
Apply a 15% discount to each price in this list [50, 150, 250]
for price in [50, 150, 250] return price * 0.85
Result:
[42.5, 127.5, 212.5]
Evaluating and Transforming Context Data
Given this context containing different types of services and their respective details, write a FEEL expression that iterates through the services and constructs a new list of contexts. Each new context will include a formatted (upper case()) label with the service name and a value based on the service elements.
{
  "services": ["training","consulting","support"],
  "training":{
    "format": "Online",
    "roles": ["Developer","Sys Admin"],
    "numPeople": 20
  },
  "consulting":{
    "description":"Project follow-up"
  },
  "support":{
    "type":"gold"
  }
}
Expression:
for s in services
    return {
        "label": upper case(s),
        "value": if(s = "training") then 
        "Format: " + training.format + " - " + string(training.numPeople) + " people - Roles: " + string join(training.roles, ", ")
        else if(s = "consulting") then 
        get value(consulting, "description")
        else
        get value(support, "type")
    } 
Result:
[
    {
        "label":"TRAINING",
        "value":"Format: Online - 20 people - Roles: Developer, Sys Admin"
    },
    {
        "label":"CONSULTING",
        "value":"Project follow-up"
    },
    {
        "label":"SUPPORT",
        "value":"gold"
    }
]

Example2:
{
  "invoices": [
    {
      "id": "INV001",
      "items": [
        { "description": "Widget", "price": 10, "quantity": 3 },
        { "description": "Gadget", "price": 15, "quantity": 2 }
      ]
    },
    {
      "id": "INV002",
      "items": [
        { "description": "Thingamajig", "price": 7, "quantity": 5 },
        { "description": "Doohickey", "price": 20, "quantity": 1 }
      ]
    }
  ]
}
Problem:
Write a FEEL expression that iterates over the invoices and, for each one, calculates a total amount by summing over the line items (using a nested iteration).
for inv in invoices
    return {
        "id": inv.id,
        "total": sum( for item in inv.items return item.price * item.quantity )
    }
result :
[
  { "id": "INV001", "total": 60 },   // (10*3 + 15*2 = 30 + 30)
  { "id": "INV002", "total": 55 }    // (7*5 + 20*1 = 35 + 20)
]

Example 3:
{
  "departments": [
    {
      "name": "Engineering",
      "employees": [
        { "name": "Alice", "salary": 7000, "bonus": 0.1 },
        { "name": "Bob", "salary": 6500, "bonus": 0.15 }
      ]
    },
    {
      "name": "Marketing",
      "employees": [
        { "name": "Charlie", "salary": 5000, "bonus": 0.05 },
        { "name": "Dana", "salary": 5500, "bonus": 0.07 }
      ]
    }
  ]
}
Problem:
Write a FEEL expression that iterates through the departments. For each department, compute the total cost of employees where the cost for an employee is calculated as salary increased by their bonus percentage. Return a new context with the department name and its total cost.
for dept in departments
    return {
       "department": dept.name,
       "totalCost": sum( for emp in dept.employees return emp.salary * (1 + emp.bonus) )
    }
result :
[
  { "department": "Engineering", "totalCost": 15175 },  // (7000*1.1 + 6500*1.15 = 7700 + 7475)
  { "department": "Marketing", "totalCost": 11135 }       // (5000*1.05 + 5500*1.07 = 5250 + 5885)
]

Example 4 :
{
  "orders": [
    {
      "orderId": "ORD1001",
      "customer": "Acme Corp",
      "items": [
        { "product": "Laptop", "price": 1200, "quantity": 2 },
        { "product": "Mouse", "price": 25, "quantity": 5 }
      ],
      "discountCode": "SUMMER"
    },
    {
      "orderId": "ORD1002",
      "customer": "Globex Inc",
      "items": [
        { "product": "Desktop", "price": 800, "quantity": 3 },
        { "product": "Keyboard", "price": 50, "quantity": 3 }
      ]
      // discountCode is not provided for this order
    }
  ]
}
Problem:
Write a FEEL expression that iterates over each order and builds a new context containing:

The orderId
A computed total amount (using a nested loop to sum each item's price * quantity)
A message indicating whether a discount was applied. If a discountCode exists, the message should read "Discount Applied: [discountCode]"; otherwise, it should read "No Discount".
FEEL Expression:
for order in orders
    return {
       "orderId": order.orderId,
       "total": sum( for item in order.items return item.price * item.quantity ),
       "message": if( defined(order.discountCode) )
                    then "Discount Applied: " + order.discountCode
                    else "No Discount"
    }
Result :
[
  {
    "orderId": "ORD1001",
    "total": 2525,          // (1200*2 + 25*5 = 2400 + 125)
    "message": "Discount Applied: SUMMER"
  },
  {
    "orderId": "ORD1002",
    "total": 2550,          // (800*3 + 50*3 = 2400 + 150)
    "message": "No Discount"
  }
]



CUSTOM FUNCTIONS :
Custom functions in FEEL allow you to encapsulate complex logic into reusable blocks. This helps in simplifying expressions, improving readability, and promoting reuse across different decision tables and business rules.
Defining Custom Functions
To define a custom function in FEEL, you specify the function name, parameters, and the expression that the function evaluates.
syntax :
function(parameter1, parameter2, ...) expression
Example: Define a function to calculate the square of a number:
{
  square: function(x) x * x
}
Example: Define a custom function to calculate the area of a circle given its radius:
{
  pi: 3.14159,      
  areaOfCircle : function(radius) (pi * radius * radius),
  result: areaOfCircle(3)
}.result
Output:
28.27431
You can also define functions that take multiple parameters. For example, a function to calculate the sum of two numbers:
{
  sumTwoNumbers: function(a, b) a + b
}
Example: Use the sumTwoNumbers function to add 3 and 5:
{
  sumTwoNumbers: function(a, b) a + b,
  result: sumTwoNumbers(3,5)
}.result
Output:
8
Example1:
Define a function to create a custom welcome message according to the current time and the user name. e.g. Good Morning, Alice!
{
  "greet": function(userName) 
    if now().hour < 12 then "Good Morning, " + userName + "!" 
    else if now().hour < 18 then "Good Afternoon, " + userName + "!"
    else "Good Evening, " + userName + "!",
  "welcomeMessage": greet("Alice")
}.welcomeMessage
Result:
"Good Morning, Alice!"
Example2:
Define a custom function to return the number of days remaining until a date in the future. e.g. 12 days
{
  daysFromToday: function(futureDate) 
    string((futureDate - today()).days) + " days",
  result: daysFromToday(date("2025-06-25"))
}.result
Result:
"366 days"

EXAMPLE PROBLEMS:
{
  "processInstance": {
        "id": "P123456789",
        "startDate": "2023-01-01T09:00:00Z",
        "tasks": [
            {"id": "T2", "name": "Gather Requirements", "duration": 120, "completed": true},
            {"id": "T6", "name": "Deployment", "duration": 90, "completed": false},
            {"id": "T4", "name": "Implement Solution", "duration": 240, "completed": false},
            {"id": "T3", "name": "Design Solution", "duration": 180, "completed": false},
            {"id": "T5", "name": "Testing & QA", "duration": 180, "completed": false},
            {"id": "T1", "name": "Initial Assessment", "duration": 60, "completed": true}      
        ],
        "variables": {
        "budget": 10000,
        "expenses": 4500,
        "stakeholders": [
            {"name": "Alice", "role": "Sponsor"},
            {"name": "Bob", "role": "Product Owner"},
            {"name": "Charlie", "role": "Lead Developer"}
        ]
    }
  }
}
Example1:
Calculate Total Duration of Completed Tasks
Write a FEEL expression to calculate the total duration of all completed tasks. Update the processInstance object by adding a new element totalCompletedDuration with the calculated value.
context put(processInstance, "totalCompletedDuration", sum(processInstance.tasks[completed = true].duration))
Result:
{
"variables": {
    "stakeholders": [
        {"name": "Alice", "role": "Sponsor"},
        {"name": "Bob", "role": "Product Owner"},
        {"name": "Charlie", "role": "Lead Developer"}
    ],
    "expenses": 4500,
    "budget": 10000
},
"id": "P123456789",
"tasks": [
    {"id": "T2", "name": "Gather Requirements", "duration": 120, "completed": true},
    {"id": "T6", "name": "Deployment", "duration": 90, "completed": false},
    {"id": "T4", "name": "Implement Solution", "duration": 240, "completed": false},
    {"id": "T3", "name": "Design Solution", "duration": 180, "completed": false},
    {"id": "T5", "name": "Testing & QA", "duration": 180, "completed": false},
    {"id": "T1", "name": "Initial Assessment", "duration": 60, "completed": true}      
],
"totalCompletedDuration": 180,
"startDate": "2023-01-01T09:00:00Z"
}
Example2 :
Check Budget Status
Write a FEEL expression that compares the current expenses against the budget and determines the budget status as "Under Budget", "On Budget", or "Over Budget". Update the processInstance variables with a new key-value pair budgetStatus.
context put(processInstance.variables,"budgetStatus",if processInstance.variables.expenses < processInstance.variables.budget then "Under Budget" else if processInstance.variables.expenses = processInstance.variables.budget then "On Budget" else "Over Budget")
Result:
{
    "stakeholders": [
        {
        "role": "Sponsor",
        "name": "Alice"
        },
        {
        "role": "Product Owner",
        "name": "Bob"
        },
        {
        "role": "Lead Developer",
        "name": "Charlie"
        }
    ],
    "expenses": 4500,
    "budget": 10000,
    "budgetStatus": "Under Budget"
}
Example3:
Identify and Sort the Next Task to Complete
Write a FEEL expression to find the first uncompleted task in the process sorted by id in alphabetical order. Update the processInstance object by adding a new element nextTask which should be the name of the next task to complete.
context put(processInstance, "nextTask", sort(processInstance.tasks[not(completed)], function(x,y) x.id< y.id)[1].name)
Result:
{
    "variables": {
        "stakeholders": [
            {"name": "Alice", "role": "Sponsor"},
            {"name": "Bob", "role": "Product Owner"},
            {"name": "Charlie", "role": "Lead Developer"}
        ],
        "expenses": 4500,
        "budget": 10000
    },
    "id": "P123456789",
    "tasks": [
        {"id": "T2", "name": "Gather Requirements", "duration": 120, "completed": true},
        {"id": "T6", "name": "Deployment", "duration": 90, "completed": false},
        {"id": "T4", "name": "Implement Solution", "duration": 240, "completed": false},
        {"id": "T3", "name": "Design Solution", "duration": 180, "completed": false},
        {"id": "T5", "name": "Testing & QA", "duration": 180, "completed": false},
        {"id": "T1", "name": "Initial Assessment", "duration": 60, "completed": true}      
    ],  
    "nextTask": "Design Solution",
    "startDate": "2023-01-01T09:00:00Z"
}

Example4:
Custom Function for Stakeholder Roles
Create a custom FEEL function named stakeholderRoles that takes the stakeholders list and returns a list of roles. Use this function to update the processInstance object by adding a new property rolesList that contains the list of roles from the stakeholders.
{
    "getList": function(stakeholders) for s in stakeholders return s.role,
    "listOfRoles": getList(processInstance.variables.stakeholders),
    "processInstanceUpdated": context put(processInstance, "rolesList", listOfRoles)
}.processInstanceUpdated
Result:
{
    "rolesList": [
        "Sponsor",
        "Product Owner",
        "Lead Developer"
    ],
    "variables": {
        "stakeholders": [
            {"name": "Alice", "role": "Sponsor"},
            {"name": "Bob", "role": "Product Owner"},
            {"name": "Charlie", "role": "Lead Developer"}
        ],
        "expenses": 4500,
        "budget": 10000
    },
    "id": "P123456789",
    "tasks": [
        {"id": "T2", "name": "Gather Requirements", "duration": 120, "completed": true},
        {"id": "T6", "name": "Deployment", "duration": 90, "completed": false},
        {"id": "T4", "name": "Implement Solution", "duration": 240, "completed": false},
        {"id": "T3", "name": "Design Solution", "duration": 180, "completed": false},
        {"id": "T5", "name": "Testing & QA", "duration": 180, "completed": false},
        {"id": "T1", "name": "Initial Assessment", "duration": 60, "completed": true}      
    ],
    "startDate": "2023-01-01T09:00:00Z"
}







IN CAMUNDA WE HAVE SERVICE TASK:
IN THAT WE HAVE TASK DEFINATION..
task defination : task defination defines which job workers can execute the task..when the service is encountered in a process instance,a corresponding job is created..the process instance is stops here and waits until the job has been completed...
Job worker :
A job worker can subscroibe to a job type,process the job and complete them using one of the zeebe clients..once the job is complete,the service task is complete an dthe process instance continues..

DEPLOYMENT :
deployment allows the process defination to be executed by the zeebe engine..

INSTANCE :
one execution of a process defination is called a process instance.many process instance can be launched from one process defination.

JOB WORKER :
a job worker can be thought of as a specialized client.
clients connect to camunda platform 8 through grpc,a high performance,open source and universal rpc protocol.



Zeebe Client - The Zeebe Client allows you to interact with Zeebe using the API
Job Worker - The Job Worker is responsible for requesting Jobs of a defined type from the Zeebe Engine
Job Handler - A Job Worker is a service capable of performing a particular task in a process. Job Workers are used to manage the interactions between the Zeebe Engine and the outside world.


Zeebe Clients allow applications to perform the following:
Deploy a Process Definition
Start and Cancel a Process Instance
Activate Jobs and Complete Jobs
Update Process Variables







CREATING A MAVEN PROJECT USING COMMAND LINE :
IN ECLIPSE GI TO THE DIRECTORY WORKSPACE AND OPEN TERMINAL AND ENTER THE COMMANDS
1.Start a Command Prompt e.g. Terminal or PowerShell

2.Change to an appropriate directory e.g. your IDE workspace

3.Create a Maven Project using the following command

mvn archetype:generate \
-DgroupId=com.camunda.academy \
-DartifactId=c8-getting-started-microservice-orchestration-lab \
-DarchetypeArtifactId=maven-archetype-quickstart \
-DarchetypeVersion=1.4 \
-DinteractiveMode=false
4.Maven will generate the new project and will output something similar to the following if everything has been successful

[INFO] Project created from Archetype in dir: C:\DevTools\Workspace\eclipse\camunda-academy\c8-getting-started-microservice-orchestration-lab
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  3.457 s
[INFO] Finished at: 2022-12-09T14:44:55Z
[INFO] ------------------------------------------------------------------------
5.Change to the newly created project using cd c8-getting-started-microservice-orchestration-lab

6.Confirm that the project can be built using mvn clean package

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  2.926 s
[INFO] Finished at: 2022-12-09T14:54:20Z
[INFO] ------------------------------------------------------------------------




CREATING MAVEN PROJECT USING AN IDE :
Add the Java Client Dependency
We will now add the Java Client dependency into our Maven project to gain access to the convenience functions that have been provided.

1.Add the following dependency to your pom.xml

  <dependency>
    <groupId>io.camunda</groupId>
    <artifactId>zeebe-client-java</artifactId>
    <version>${zeebe.version}</version>
  </dependency>
Java Client Version
You should use the latest stable version of the Java Client from the Maven Repository.
At the time of writing, the latest stable version is 8.3.0.
Spring Boot
If you are building a Spring or Spring Boot application, you may want to use the Spring Zeebe dependency instead of handling the lifecycle and configuration of the Java client yourself.
The Spring Zeebe client is a community maintained client which is not officially supported by Camunda.

2.Confirm that the project can be built using mvn clean package

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  2.926 s
[INFO] Finished at: 2022-12-09T14:54:20Z
[INFO] ------------------------------------------------------------------------


Connect to the Cluster
We will now connect to the Cluster to ensure that everything is working as expected before implementing the handler for our Job Worker.
Configure Connection Properties
For the purposes of simplicity, we will configure the connection properties for our Job Worker as Java constants. In a real-world application these properties would be picked up from an application.properties file or environment variables based upon the development framework that you are using.
1.Create a new PaymentApplication Class with a main method in the com.camunda.academy package
2.Add the following constants to your Class

private static final String ZEEBE_ADDRESS = "[ZEEBE_ADDRESS]";
private static final String ZEEBE_CLIENT_ID = "[ZEEBE_CLIENT_ID]";
private static final String ZEEBE_CLIENT_SECRET = "[ZEEBE_CLIENT_SECRET]";
private static final String ZEEBE_AUTHORIZATION_SERVER_URL = "[ZEEBE_AUTHORIZATION_SERVER_URL]";
private static final String ZEEBE_TOKEN_AUDIENCE = "[ZEEBE_TOKEN_AUDIENCE]";
3.Replace each of the constants in square brackets with the values from your CamundaCloudMgmtAPI-Client-Camundanzia.txt which you downloaded in an earlier lesson
Connection Properties :
ZEEBE_ADDRESS - The address to reach the Zeebe Cluster, i.e. a standalone or embedded gateway or a proxy / load balancer sitting in front of a Zeebe Cluster
ZEEBE_CLIENT_ID - The unique identifier of the Client for the OAuth2 provider
ZEEBE_CLIENT_SECRET - The pre-shared secret for the OAuth2 provider
ZEEBE_AUTHORIZATION_SERVER_URL - The URI from which an Access Token can be requested from
ZEEBE_TOKEN_AUDIENCE - The audience of the Client token for the OAuth2 provider

Configure the Credentials Provider :
We now need to create an OAuthCredentialsProvider so that our Client can authenticate with the Cluster.
1.Add the following snippet to the main method to instantiate the OAuthCredentialsProvider:

final OAuthCredentialsProvider credentialsProvider =
    new OAuthCredentialsProviderBuilder()
        .authorizationServerUrl(ZEEBE_AUTHORIZATION_SERVER_URL)
        .audience(ZEEBE_TOKEN_AUDIENCE)
        .clientId(ZEEBE_CLIENT_ID)
        .clientSecret(ZEEBE_CLIENT_SECRET)
        .build();

Create a Zeebe Client :
We can now create a Zeebe Client which will connect to our Cluster using the address and credentials that have been made available through our constants:
1.Add the following snippet to the main method beneath the instantiation of the OAuthCredentialsProvider:

final ZeebeClient client =
    ZeebeClient.newClientBuilder()
        .gatewayAddress(ZEEBE_ADDRESS)
        .credentialsProvider(credentialsProvider)
        .build();
Close the Client
The Zeebe Client connection should be closed when it is no longer needed. Whilst the snippet above will work, a try-with-resources statement would be a better implementation here to ensure that resources are cleaned up.

2.Modify the snippet above so that the Zeebe Client will be cleaned up after use

try (final ZeebeClient client =
        ZeebeClient.newClientBuilder()
            .gatewayAddress(ZEEBE_ADDRESS)
            .credentialsProvider(credentialsProvider)
            .build()) {
} catch (Exception e) {
    e.printStackTrace();
}

Make a Request :
Before we implement the functionality for our Job Worker, we can make a simple request to retrieve the Topology of the Cluster.
1.Modify the Zeebe Client snippet so that it now reflects the following:

try (final ZeebeClient client =
        ZeebeClient.newClientBuilder()
            .gatewayAddress(ZEEBE_ADDRESS)
            .credentialsProvider(credentialsProvider)
            .build()) {
    System.out.println("Connected to: " + client.newTopologyRequest().send().join());
} catch (Exception e) {
    e.printStackTrace();
}

Remember to Send :
Requests sent to the Zeebe API from a Client are asynchronous; Clients use the same pattern to make requests against the API for consistency and ease of use.

Obtain a new Command object from the Client
Configure the Command object (specific to each Command e.g. CreateInstanceCommand)
Send the Command to the Zeebe API
Join the Future object to wait for and handle the response

Always remember to Send the Command after it has been configured and Join the Future to wait for and handle the response.

Test the Connection :
We can now test the connection between our Client and the Cluster:
If you now run the PaymentApplication from your IDE or Maven, you should get a connection to the Cluster and a response similar to the below:
Connected to Camunda 8: TopologyImpl{brokers=[BrokerInfoImpl{nodeId=1, host='zeebe-1.zeebe-broker-service.5f400cdf-a978...














TECHNICAL OVERVIEW :
camunda 8 components -
modeler,zeebe engine,tasklist,operate,optimize.

zeebe engine - it is the process automation engine powering camunda 8.it follows a unique architecture that allows scalability and fault tolerance
modeler - it helps u to design the bpmn process diagram and implement them...u can usae connectors directly..
connectors - they are building blocks that perform the integration with external systems.
tasklist - it is a ready to use that allows to view and manage assigned tasks..
operator - it is a tool for monitoring and troubleshooting the process instance running in the zeebe.
optimize - it is a powerful analytics tool..


OPERATE :
3 views :global instances, instances by process defination and incidents by error message


CONNECTORS :
connectors offers a multilayered coding experience 
connectors consists of two parts :
1.the programming code in java to connect to the external system (for example connectors)
2.the user interface to be used during modeling, which is provided using connectors template..







CONNECTORS INTRRODUCTION  
connectors are represented by a concrete task in bpmn process in modeler..connectors are resuable building blocks that enables connectivity to outside systems..they can be easily be added to a bpmn diagram using camunda modeler and configured without the code..
the components of connectors are :
1.the programming code in java to connect to external systems...
2.the user interface to be used during modeling,which provided using camunda connector template..
camanda 8 provides variety of out of bound connectors.they reduce the time and effort required to develop process automation solutions.
they are two types of connectors. they are:
Inbound connectors -
allows process instance to be started or influenced by the external system or service.it triggers process automatically..it can be message event or receive task.

Outbound connectors -
allows process instance to issue a request to an external system or a service.allows process instance to invoke business logic managed outside of camunda..it can be message throw or service task..


What is an Incident?
An Incident represents a problem in process execution. This means that a process instance is stuck at a particular point, and requires user interaction to resolve the problem.
Incidents are created in different situations, including the following:
A Job is failed and it has no retries left.
An input or output variable mapping can't be applied.
A condition can't be evaluated.
A decision can't be evaluated.



What is a Job?
A Job represents a task that needs to be performed by a process. For example, a Job is created by Zeebe whenever a process instance reaches a Service Task. A Job representing the Service Task must be completed before the process is able to continue.

What is a Job Worker?
A Job Worker is a service capable of performing a particular task in a process.A job worker implements the business logic required to complete a task. Job Workers are used to manage the interactions between the Zeebe Engine and the outside world and perform the following actions:
Request Jobs - Request jobs of a certain type on a regular interval (i.e. polling). This interval and the number of jobs requested are configurable.
Complete or Fail Jobs - After working on an Activated Job, a Job Worker informs Zeebe that the Job has either Completed or failed.
A Job Worker may either Complete or Fail a Job.
Complete - When the Job Worker completes its work, it sends a complete job command along with any variables, which in turn is merged into the process instance. This is how the Job Worker exposes the results of its work.
Fail - If the Job Worker cannot successfully complete its work, it sends a fail job command along with an error message.


CONNECTORS :
What are connectors
Connectors are building blocks that allow for the execution of code, that usually involves integrations with other systems.A connector is composed of several components that allow for modeling, runtime behavior, and reuse as a reusable building piece.
Main advantages
Connectors bring the following benefits:
They are focused on business logic
Runtime-agnostic
Abstracted from Zeebe API
Allow processes to connect to outside systems to orchestrate work
Reduce costs in maintenance because they can be reused in different environments
Camunda provides a list of out of the box connectors
Custom connectors can be implemented to tailor the project needs
connectors types  :
Connectors are categorized by the direction data flows into or out of Camunda.
Outbound connectors allow workflows to trigger external systems or services, making it possible to integrate workflows with other parts of a business process or system architecture. The Java code is executed when the workflow reaches the service task.
Inbound connectors enable workflows to receive data or messages from external systems or services, making it possible to integrate workflows into a wider business process or system architecture. Inbound Connectors can be used to create a new process instance, or to send a message to a running process instance.
CONNECTOR COMPONENTS :
A connector consists of a Connector Template and a Connector Implementation, executed by a Connector Runtime Environment.

The @ElementTemplate is the way to configure the ðŸ”—Element Template Generator to generate the connector template automatically based on the Java data model.
It is a great way to ensure your template is always synchronized with your Java code and automate some of the effort.





JOB WORKER -
job worker is a service capable of performing a particular task in a process..each time such a task is performed,thi is represented by a job..a job worker uses the client api to activate jobs and complete or fail jobs...job worker request jobs of certain type on a regular interval which is called as pooling..if one or more jobs of the requested type is available,zeebe streams activated jobs to the worker..upon receiving jobs,a worker performs them and sends back a complete or fail command for each job...


HOW THE JOB WILL GET COMPLETED -
after activation,the worker will have to perform two action..first tackle its use case,which could involve anything from writing data to the database,to interacting to nasa system dependoing on the business requirements....second,communicate with the zeebe to indicate that the job is done..zeebe will then move the token to the next element..whjich action to execute first???well it depends..both are possible..and lead to different outcomes..

synchronous setup -
the worker executes the business logic first and then sends back the result to the zeebe..the result can be either complete message or complete failure..zeebe will be informed of the status and can react accordingly..the busiiness logic can be executed twice...the worker will have to handle the situation...the transaction underlying the business logic will need to be idempotent( means something can be repeated multiple times without changing the outcome)...the way of achieving this is by providing a transaction identifier..


asynchronous setup -
first the approach consists in completing the job first,informing zeebe about the task completion,and then executing the business logic...it provides speed because zeebe will not wait for the completion of the job...it is a good choice for cases where zeebe doesn't need data returned from worker,like sending mails..if an error occurs in executing the business logic,the worker will have to handle it on its own without the help of zeebe..in other words,the worker will have to become stateful with a higher level of complexity...






EVENT SUBPROCESS -
it is a type of subprocess that is triggered by an event..it can be used globally as a process or locally within the subprocess....

WHY ARE EVENT SUBPROCESS USEFUL ?
A subprocess should contain a group of elements with common functionality...


COMPENSATION EVENTS -
compensation events are a means of representing the reversal or undoing of a process activity that has already been completed...a compensation catch event can only be triggered by a compensation throw event....catching events are always attched to an activity..throw events can be intermediate or end events..if a compensation throw event is inside an embedded subprocess,only the subprocess compensation handlers are invoked...
COMPENSATION THROW EVENT -
throw events can be intermediate or end events..
COMPENSATION INTERMEDIATE THROW EVENTS -
this events is used to expecitly trigger compensation for completed activities..it triggers the compensation for the process or a specific activity in the process...
COMPENSATION END EVENTS -
this event triggers compensation and the current path of execution is ended..it has the same behavior and limitations as a compensation intermediate throwing event..

ATTACHED COMPENSATION EVENTS -
COMPENSATION BOUNDARY EVENT -
this is attached to an activity that might need to be compensated...




INCLUSIVE GATEWAY -
	inclusive gateway or OR gateway,are used in BPMN to diverge the flow of multiple paths based on conditions..unlike exclusive gateway that select only one path inclusive gateways can activate multiple paths based on conditions met..they allow for more flexible decision making workflows....
inclusive gateways are used in BPMMN to diverge the flow of multiple paths based on conditions..inclusive gateways can activate multiple paths simultaneously...


BPMN MARKERS -
marker can be added to an activity to define a specific behavior for that activity...
MARKER TYPES -
loop markers,ad-hoc marker,compensation marker,multi-instance marker which can be parallel or sequencial....

LOOP MARKER -
when used on activity,it wikk cause that activity to run multiple times in a loop,and will check for a specific condition before or after each repetition...it can be used in th edesign mode in camunda modeler,but can't be run because isn't supported by the camunda engine...

AD-FOC MARKER -
an ad-hoc marker is represented with a tilde symboland can only be used on a subprocess,and will change that subprocess into ad-hoc subprocess...all activities contained within an ad-hoc subprocess can be run any number of times and can be run in any order...

COMPENSATIOIN MARKER -
compensation marker is represented with two backward facing arrows,indicating that it can be used to undo a previously completed activity...it is included on default on a compensation handler,which is an activity that is associated to a compensation boundary event....


PARALLEL ACTIVITY -
when used on an activity,it will run all instances of that activity simultaneously or it will run in parallel with each other.....

SEQUENTIAL MULTI-INSTANCE MARKER -
the sequential multi-instance marker is represented with an icon that has three horizontal lines stacked on each other or it will run the instance in a sequence,one at a time.....


PROCESS DEFINATION -
it is the static model of the business process created using bpmn..


PROCESS INSTANCE -
it is a single, runtime execution of that process definition..

PROCESS INSTANCE MIGRATION -
migration is done to a process instance running on one version o fthe process definition to have it continuing onto on a different version of the process definition



STATEGIC PROCESS MODELS -
high level,logic adstract,not meant to be automated..used by everyone,but especially process managers and process owners....process is easily read and understood...


OPERATIONAL PROCESS MODELS -
low level,logically concrete,focused on automation....used by process participants(focused on human workflow),process engineers(focused on technical workflow),process analyst(focused on the whole collaboration)....process is detailed and executable...





VARIABLE SIZE LIMITATION -
there is a limit of 4 MB for the payload of a process instance. This 4 MB includes the variables and the workflow engine internal data, which means there is slightly less memory available for variables. The exact limitation depends on a few factors, but you can consider 3 MB as being safe. 



Hit policy -
hit policy determines how decisions are made, and which outcomes are prioritized..it contains two decision they are output and result..hit policy define how outputs are aggregated or selected to produce the final result..the hit policy influences the readabilityand maintainability of the decision table..hit policy determines the final result..
output - the output contains the sprecific value literal or expression..calculation an dfunction calls are added here..
they are categorized into two hit policies..they are single and multiple hit policies...
SINGLE HIT POLICY -
single hit policy such as unique,first and any produces one result based on one matching rule.single hit policies are ideal for scenarios requiring decisive outcome,such as,
medical triage(where only the most critical condition should be treated first),user authentication(only the first correct password should grant access)
UNIQUE HIT POLICY -
it means only one rule will apply or no rule at all..and it is the default if no policy is deternmined...common applications for the unique hit policy are:
determininf discounts,determining the employee responsible for the task..the unique hit policy requires that the decision result contains the output entries of only one satisfied rule..if multiple rules are satisfied it indicates a policy voilation..
Example : when there are 4 guests and the season is winter rule 3 and 6 overlap because they overlap because they share this inputs..
MULTIPLE HIT POLICY -
multiple hit policy such as collect,rule order and output order consider all matching rules and may return multiple results..multiple hit policies are better suited for scenarios requiring comprehensive results,such as,
compiling  a shooping list from multiple meal plans,gathering all applicable discounts on a purchase..








reading an email and storing the email in the .msg file and saving the file in a particular path


reading an email and storing the email in the .msh file and saving the file in a particular path

CONVERT .EML TO .MSG
convert .mht to .msg
jotlmsg dependency





IN SAAS WE CAN CREATE ONLY ONE CLUSTER...IF WE CREATE ONE CLUSTER WE CANNOT CREATE ANOTHER ONE AS IT WILL AUTOMATICALLY BE DISABELED..



OPERATOR - 
IT IS A TOOL FOR MONITORING AND TROUBLESHOOTING PROCESS INSTANCES RUNNING IN THE ZEEBE ENGINE..IN ADDITION TO PROVIDING VISIBILITY INTO ACTIVE AND COMPLETED PROCESS INSTANCE, OPERATE ALSO MAKES IT POSSIBLE TO CARRY OUT KEY OPERATIONS SUCH AS RESOLVING INCIDENTS, AND UPDATING PROCESS INSTANCE VARIABLE...




















nisasi4930@erapk.com
Narayana@123
